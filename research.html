<html><head><title></title></head><body><h1>「IoTに基づくスマートホームシステムの設計と実装」のあらまし</h1>
<h2>はじめに</h2>
<p>本論文は、スマートホームシステムのフレームワークの構築への検討である。</p>
<p>本システムは、ユビキタスセンシングネットワーク、データーベース、中央コントロールシステムとリモコン端末からなっている。このシステムは、居場所の環境要素を検出し情報源として家屋にある家電用品を遠隔操作できるものである。本研究に通して、スマートホームシステムの構築方法を検討しIoTの要素を理解し更に発展することを目的とする。</p>
<h2>システムデザイン</h2>
<p>普通には、スマートホームに対して、温度、湿度、照度が基本的な環境要素であって、インテリジェントカーテンも基本的なインテリジェント家電用品である。それらを例に考えて以下のようになる。</p>
<p><img src="http://izumisagiri.github.io/system.png" alt="system" title="システムデザイン" /></p>
<h2>ハードウェアとソフトウェアの選定</h2>
<h3>温度センサー</h3>
<p>DS18B20を選定する。測定温度範囲は-55℃～+125℃で、精度は±0.5℃であって、1-Wireバス上で通信を行う。電源動作範囲は3.0V～5.5Vである。</p>
<h3>湿度センサー</h3>
<p>AM2001を選定する。電源動作範囲は4.5V～6Vである。精度は±3%RHである。アナログセンサである。</p>
<h3>A/D&amp;D/Aコンバータチップ</h3>
<p>PCF8591を選定する。電源動作範囲は2.5V～6Vである。I2Cインターフェース上で通信を行う。</p>
<h3>マイコン</h3>
<p>最も基本的なマイコンSTC89C52RCを選定する。C言語を使ってプログラミングする。</p>
<h3>中央コントローラー</h3>
<p>誰も持っているパソコンを選定する。</p>
<h3>近距離無線通信モジュール</h3>
<p>現在、ユビキタスネットワークのプロトコールにはRFやBluetooth、WiFi、Zigbee、Z-Waveがある。WiFiが省エネではなく、Bluetoothの通信距離がただ10ｍであり、ZigbeeとZ-Waveが複雑なユビキタスネットワーク向けプロトコールであると考えていてRFを選定する。ノルディック社のnRF24L01は2.4GHz帯を使って通信を行っている。この2.4GHz帯は免許不要で自由に利用できる。</p>
<h3>中央コントロールソフトウェアの開発の言語</h3>
<p>データーベースを使う必要及びリモコン端末が使える希望があるので、C#+SQLSERVER+ASP.NETを選定する。C#はオブジェクト指向言語であり、SQLSERVER及びASP.NETと繋ぎやすい。</p>
<h3>サーバーの構築手法</h3>
<p>パソコンでIISをインストールしてnat123が提供した無料ドメインを取得してサーバーを構築する。</p>
<h2>温度及び湿度を検出するプログラムの開発</h2>
<h3>温度を検出するプログラム</h3>
<p>DS18B20の初期化</p>
<p><img src="http://izumisagiri.github.io/initiate.png" alt="initiate" title="初期化" />;</p>
<p>初期化プログラムは以下のようになる。</p>
<pre><code>void DS18B20_Reset(void)
{
    unsigned int i;

    DS_Data = 0;
    i = 103;
    while(i&gt;0)  i--;

    DS_Data = 1;
    i = 4;
    while(i&gt;0)  i--;
}
</code></pre>
<p>DS18B20の入力と出力</p>
<p><img src="http://izumisagiri.github.io/0and1.png" alt="0and1" title="入力と出力" />;</p>
<p>入力と出力プログラムは以下のようになる。</p>
<pre><code>bit DS18B20_ReadBit(void)                       //1bitを読み込む
{
    unsigned int i;
    bit dat;

    DS_Data = 0;
    i++;
    DS_Data = 1;
    i++;
    i++;
    dat = DS_Data;

    i = 8;
    while(i&gt;0)  i--;

    return (dat);
}
uchar DS18B20_ReadByte(void)                        //1Byteを読み込む
{
    unsigned char i,j,dat;
    
    dat=0;
    for(i=1; i&lt;=8; i++)
    {
        j = DS18B20_ReadBit();
        dat=(j&lt;&lt;7)|(dat&gt;&gt;1); 
    }

    return(dat);
}
void DS18B20_WriteByte(unsigned char dat)               //1Byteを書き込む
{
    unsigned int i;
    unsigned char j, k;
    bit b;

    k = dat;

    for(j=1; j&lt;=8; j++)
    {
        b = k &amp; 0x01;
        k = k &gt;&gt; 1;
        if(b)                           //1を書き込む
        {
            DS_Data = 0;
            i++; i++;
            DS_Data = 1;
            i = 8;
            while(i&gt;0) i--;
        }
        else
        {
            DS_Data = 0;                    //0を書き込む
            i = 8;
            while(i&gt;0)  i--;
            DS_Data = 1;
            i++; i++;
        }
    
    }
}
</code></pre>
<p>温度を検出するプログラムは以下のようになる。</p>
<pre><code>void DS18B20_Change(void)                       //DS18B20を始動する
{
    DS18B20_Reset();                        //初期化
    delayDSMs(5);
    DS18B20_WriteByte(0xcc);                    //DS18B20は一つだけであるから、ROMを使わない
    DS18B20_WriteByte(0x44);                    //温度検出を始める
}
int DS18B20_GetTemp()                           //温度検出の結果を読み込む
{
    float t;
    unsigned char a, b;
    int temp;
    
    DS18B20_Reset();                        //初期化
    delayDSMs(5);
    DS18B20_WriteByte(0xcc);                        //ROMを使わない
    DS18B20_WriteByte(0xbe);                        //結果を読み込む
    a=DS18B20_ReadByte();
    b=DS18B20_ReadByte();
    
    temp = b;
    temp &lt;&lt;= 8;
    temp = temp|a;                          //データの高位と低位を合成する
    t = temp*0.0625;                        //デフォルト精度は12ビットであり，即ち0.0625℃である
    temp = t*10+0.5;
    
    return temp;
}
</code></pre>
<h3>湿度を検出するプログラム</h3>
<p>湿度センサはアナログセンサであるのでA/D&amp;D/Aコンバータチップを動かすプログラムが必要になる。
PCF8591の初期化
I2Cを初期化するのはSDA及びSCLをHighにすること。プログラムは以下のようになる。</p>
<pre><code>void init_IIC()
{
    SDA=1;
    delayADDA();
    SCL=1;
    delayADDA();
}
</code></pre>
<p>I2Cの読み込み開始及び終止のプログラム</p>
<p><img src="http://izumisagiri.github.io/I2C.png" alt="I2C" /></p>
<pre><code>void start()
{
    SDA=1;
    delayADDA();
    SCL=1;
    delayADDA();
    SDA=0;
    delayADDA();
}
void stop()
{
    SDA=0;
    delayADDA();
    SCL=1;
    delayADDA();
    SDA=1;
    delayADDA();
}
</code></pre>
<p>I2Cのデータコミュニケーション</p>
<p><img src="http://izumisagiri.github.io/I2Cwrite.png" alt="I2C" /></p>
<pre><code>void Write_Byte(uchar dat)
{
    uchar i;
    for(i=0;i&lt;8;i++)
    {
        SCL=0;
        delayADDA();
        if(dat&amp;0x80)
        {
            SDA=1;
        }
        else
        {
            SDA=0;
        }
        dat=dat&lt;&lt;1;
        SCL=1;
        delayADDA();
    }
    SCL=0;
    delayADDA();
    SDA=1;
    delayADDA();    
}
uchar Read_Byte()
{
    uchar i,dat;
    SCL=0;
    delayADDA();
    SDA=1;
    delayADDA();
    for(i=0;i&lt;8;i++)
    {
        SCL=1;
        delayADDA();
        dat=dat&lt;&lt;1;
        if(SDA)
        {
            dat++;
        }
        SCL=0;
        delayADDA();
    }
    return dat;
}
</code></pre>
<h3>acknowledge及びnot acknowledge</h3>
<p>SCLのクロックに従って送信側から８ビットのデータが出力され、続いて受信側からアクノリッジ信号が返送される。</p>
<p><img src="http://izumisagiri.github.io/I2Cack.png" alt="ACK" title="ACK" /></p>
<pre><code>void ack()
{
    uchar i=0;
    SCL=1;
    delayADDA();
    while((SDA==1)&amp;&amp;(i&lt;250)) i++;
    SCL=0;
    delayADDA();
}
void noack()
{
    SDA=1;
    delayADDA();
    SCL=1;
    delayADDA();
    SCL=0;
    delayADDA();
}
</code></pre>
<h3>I2Cメインプログラム</h3>
<pre><code>void DAC_PCF8591(uchar add,uchar dat)
{
    start();                          
    Write_Byte(add);
    ack();
    Write_Byte(Control_Byte);
    ack();
    Write_Byte(dat);
    ack();
    stop();
}
uchar ADC_Read(uchar add0,uchar add1,uchar chl)
{
    uchar dat;
    start();
    Write_Byte(add0);
    ack();
    Write_Byte(Control_Byte|chl);
    ack();
    start();
    Write_Byte(add1);
    ack();
    dat=Read_Byte();
    noack();
    stop();
    return dat;
} 
</code></pre>
<h2>インテリジェントカーテンの設計</h2>
<p>モーターでカーテンを動かして、光電スイッチでカーテンの状態を検出する。直流モーターを使って、PWM制御でモーターの速度を変調する。</p>
<h3>電子回路</h3>
<p>設計した回路は以下のようになる。</p>
<p>電源のレギュレーション</p>
<p><img src="http://izumisagiri.github.io/wenya.png" alt="voltage" /></p>
<p>駆動回路</p>
<p><img src="http://izumisagiri.github.io/gongfang.png" alt="amplifier" /></p>
<p>PWM制御プログラム</p>
<pre><code>void PWM(int a){int i;for(i=0;i&lt;10;i++){if(i&lt;a)OUT=1;else OUT=0;}}
</code></pre>
<p>モータの正逆転制御回路「Hブリッジ回路」</p>
<p><img src="http://izumisagiri.github.io/H.png" alt="H" /></p>
<pre><code>void tingzhi()                          //モーターを止める
{
    H1=1;H2=1;H3=1;H4=1;                    //このHブリッジ回路はLowにしたら導通する
    jdq_zhuangtai = 'g';
}
void zhengzhuan()                       //モーターを回転する
{
    H3=1;H4=1;                      //安全のためにまずFETを全部ＯＦＦ状態にする
    delay();
    H1=0;H2=0;
    zhuan_direct = 'z';                 //ここで二つの有限オートマトンを設置する。方向及び状態を記録する。
    jdq_zhuangtai = 'k';
}
void fanzhuan()                         //モーターを逆回転する
{
    H1=1;H2=1;
    delay();
    H3=0;H4=0;
    zhuan_direct = 'f';
    jdq_zhuangtai = 'k';
}
</code></pre>
<h3>カーテンの状態検出</h3>
<p>FSMを使って、モーターの回転べき方向及びカーテン状態を記録できる。カーテンが完全に開かれたあるいは閉められたとき、光電スイッチはLowからHighにしてFSMも変わる。
<img src="http://izumisagiri.github.io/FSM.png" alt="FSM" /></p>
<h3>カーテンの操作パターンの設計</h3>
<p>開く、閉める、停止、再始動、変調の五つの操作パターンを構想する。これらの操作状態を表すため、以下の五つの変数を設置する。</p>
<blockquote>
<p>zhuan_stat 回転状態変数<br />
zhuan_direct 回転方向状態変数<br />
zhuan_zhuangtai カーテン状態変数<br />
jdq_zhuangtai Hブリッジ状態変数<br />
dangban 光電スイッチ状態変数</p>
</blockquote>
<p>光電スイッチはLowにしてながら回転状態変数が20にするとモーターを始動させる。</p>
<p>各操作パターンの流れは以下の流れ図の通りである。</p>
<p><img src="http://izumisagiri.github.io/control.png" alt="start" />
<img src="http://izumisagiri.github.io/control2.png" alt="stop" />
<img src="http://izumisagiri.github.io/control3.png" alt="pause" /></p>
<h2>通信プロトコールの設計</h2>
<p>以下の制御文字を定義する。</p>
<blockquote>
<p>AckX：転送開始<br />
GotX：肯定応答<br />
OpnX：カーテンを開く<br />
ClsX：カーテンを閉じる<br />
SttX：モーターを始動する<br />
PauX：モーターを停止する<br />
SpeX：速度変調</p>
</blockquote>
<p>通信を補助するためにカウンターも一つ設置する。</p>
<p>マスター側の送信流れは以下の流れ図の通りである。</p>
<p><img src="http://izumisagiri.github.io/communication1.png" alt="PC" title="パソコン" /></p>
<p>スレーブ側の送信流れは以下の流れ図の通りである。</p>
<p><img src="http://izumisagiri.github.io/communication2.png" alt="MC" title="マイコン" /></p>
<h2>中央コントロールソフトウェアの開発</h2>
<p>本設計はPC02F24をマスター側通信モジュールとして採用し、WLK02F24をスレーブ側通信モジュールとする。開発Microsoft Visual Studioを開発環境とする。</p>
<p>シリアル通信のためのファンクションクラスSerialControlHelper.cs：</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO.Ports;

namespace 物联网中控软件                       //「IoTコントロールソフトウェア」の意味
{
    public class SerialControlHelper
    {
        SerialPort sp = null;                       //COMポートをインスタンス化

        public bool SerialPortOpen(string Port)     //COMポートの初期化は成功したかどうかを戻る
        {
            sp = new SerialPort();                  //COMポートをインスタンス化
            sp.PortName = Port;                 //関数によってポートを決める
            sp.Parity = Parity.None;                //バリティチェックなし
            sp.StopBits = StopBits.One;             //ストップビットを1ビットにする
            sp.BaudRate = 9600;                 //ボーレートを9600にする
            sp.DataBits = 8;                        //データビットを8ビットにする
            sp.RtsEnable = true;    
            bool successOrNot = true;
            try
            {
                sp.Open();                          //インスタンス化したポートを開く
            }
            catch
            {
                successOrNot = false;               //失敗したら「偽」を戻る
            }
            return successOrNot;                    //戻り値
        }
        public Byte[] SerialData                    //変数SerialDataを定義する。当変数の値を読むとき
        {                                       //COMポートからのデータを読み込む
            Get                                 //読み込む
            {
                string dataTemp = sp.ReadTo(&quot;X&quot;);   //制御文字「X」まで読み込む
                ASCIIEncoding ae = new ASCIIEncoding();//ASCIIEncodingをインスタンス化する
                Byte[] dataByte = ae.GetBytes(dataTemp); //マイコンからのASCIIコードを数値にコンバートする
                return dataByte;                    //戻り値
            }
            Set                                 //書き込む
            {
                Byte[] dataByte = value;            //送信すべきデータを配列dataByteに書き込む
                int dataLength = dataByte.Length;   //配列のサイズを調べる
                sp.Write(dataByte,0,dataLength);        //シリアルポートに書き込む
            }
        }
        public bool SetTargetAddress(byte targetAddress) //PC02F24のあて先を切り替える
        {
            this.SerialData = new Byte[] {0x9d, 0x8c, 0x6b, 0x5a, 0xdd, 0x08, 0x01, targetAddress };    //コマンド
            bool successOrNot = false;
            if (sp.ReadByte() == 0x9d &amp;&amp; sp.ReadByte() == 0x8c &amp;&amp; sp.ReadByte() == 0x6b) successOrNot = true;   //戻り値は「9D 8C 6B」か
            return successOrNot;                    //戻り値
        }
        public void SendMessage(string messageText) //送信コマンド
        {
            sp.Write(messageText);
        }
        public void SendAck()                       //Ackを送信する
        {
            sp.Write(&quot;AckX&quot;);
        }
        public bool GetAck()                        //Gotを受信する
        {
            bool gotOrNot = false;
            if (sp.ReadTo(&quot;X&quot;) == &quot;Got&quot;) gotOrNot = true;
            return gotOrNot;
        }
    }
}
</code></pre>
<p>以上のクラスはポートの開き、ポートを通じての読み書き、通信あて先の切り替え、Ackの送信とAckの受信のファンクションを実現した。</p>
<h3>情報提示モジュール</h3>
<p>環境要素を提示するGUIは以下のようになる。温度、湿度、照度を提示する。</p>
<p><img src="http://izumisagiri.github.io/GUI.png" alt="environment" title="GUI" /></p>
<p>プログラムは以下のようになる。</p>
<pre><code>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading;                             //Threadingはディレーのクラス

namespace 物联网中控软件
{
    public partial class Status : Form
    {
        SerialControlHelper sc = null;                  //前にプログラミングしたクラスをインスタンス化する
        DatabaseHelper dbh = null;                      //データベースクラスをインスタンス化する
        bool timerFlag = false;                     //タイマーフラグ
        public Status()                             //モジュール名
        {
            InitializeComponent();
            sc = new SerialControlHelper();             //クラスをインスタンス化する
            dbh = new DatabaseHelper();                 //データベースクラスをインスタンス化する
            sc.SerialPortOpen(&quot;COM4&quot;);                  //COM4を開く
            dbh.OpenDatabase();                     //データベースに接続する
            CheckForIllegalCrossThreadCalls = false;        //バックグラウンドが直接にフォアグラウンドのウィジェットを操作することを許可する
            backgroundWorker1.RunWorkerAsync();         //バックグラウンドを作動させる
        }

        private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) //バックグラウンド
        {
            bool successOrNot = sc.SetTargetAddress(0x01); //PC02F24のあて先を成功的に設置したか
            toolStripStatusLabel1.Text = &quot;设置地址为01：失败&quot;;//まず「失敗した」を表す
            if (successOrNot) toolStripStatusLabel1.Text = &quot;设置地址为01：成功&quot;;//成功したら「成功した」に切り替える
            timer1.Start();                         //タイマーを始動する
            while (true)                                //バックグラウンドは無限ループに入る
            {
                if (timerFlag)                          //タイマーフラグは「真」か
                {
                    tickLbl.Text += &quot;ha&quot;;               //デバッグのための表示
                    timerFlag = false;                  //タイマーフラグを「偽」にする
                    sc.SendAck();                       //Ackを送信する
                    bool gotOrNot = sc.GetAck();            //Gotを受信したか
                    if (gotOrNot)                       //受信したら「握手成功」、受信しなかったら「握手失敗」を表す
                        toolStripStatusLabel1.Text += &quot; 握手成功&quot;;
                    else toolStripStatusLabel1.Text += &quot; 握手失败&quot;;
                    Thread.Sleep(1000);                 //１秒のフリーズが、マイコンを時間を与える所以である
                    sc.SendAck();                       //Ackを送信する
                    Byte[] dataByte = sc.SerialData;        //受信したデータを配列dataByteに書き込む
                    ASCIIEncoding ae = new ASCIIEncoding(); //ASCIIEncodingをインスタンス化する
                    string tempLblText = ae.GetString(dataByte, 0, 2) + '.' + ae.GetString(dataByte, 2, 1); //マイコンからのデータを「XX.X」のフォーマットにして導入
                    tempLbl.Text = tempLblText;         //温度値を表す
                    dbh.RenewData(&quot;Status&quot;, &quot;Temp&quot;, tempLblText);//温度値をデータベースに書き込む
                    string humLblText = ae.GetString(dataByte, 4, 2) + '%'; //次のデータを「XX%」のフォーマットにして導入
                    humLbl.Text = humLblText;           //湿度を表す
                    dbh.RenewData(&quot;Status&quot;, &quot;Hum&quot;, humLblText);//湿度をデータベースに書き込む
                    string lightLblText = ae.GetString(dataByte, 6, 1); //照度を読み込む
                    lightLbl.Text = lightLblText;       //照度を表す
                    dbh.RenewData(&quot;Status&quot;, &quot;Light&quot;, lightLblText);//照度をデータベースに書き込む
                }
            }
        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            timerFlag = true;
        }
    }
}
</code></pre>
<h3>カーテンのコントロールモジュール</h3>
<p>カーテンをコントロールするGUIは以下のようになる。状態、速度、カーテンの開き、閉じ、停止、再始動と速度変調が可能になる。</p>
<p><img src="http://izumisagiri.github.io/GUI2.png" alt="control" title="GUI" /></p>
<p>以下の変数を設置した。</p>
<blockquote>
<p>kaiQiFlag：カーテンを開くフラグ<br />
guanBiFlag：カーテンを閉じるフラグ<br />
zanTingFlag：カーテンを停止するフラグ<br />
tiaoSuFlag：速度変調のフラグ<br />
qiDongFlag：再始動のフラグ</p>
</blockquote>
<p>プログラムの一部は以下のようになる。</p>
<pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading;

namespace 物联网中控软件
{
    public partial class Curtain : Form
    {
        SerialControlHelper sc = null;                  //实例化串口方法类
        DatabaseHelper dbh = null;                      //实例化数据库方法类
        bool timerFlag = false;                     //定时器标志位
        bool kaiQiFlag = false;                     //定义上述控制位
        bool guanBiFlag = false;
        bool zanTingFlag = false;
        bool tiaoSuFlag = false;
        bool qiDongFlag = false;
        public Curtain()
        {
            InitializeComponent();
            sc = new SerialControlHelper();             //实例化串口方法类
            dbh = new DatabaseHelper();                 //实例化数据库方法类
            sc.SerialPortOpen(&quot;COM4&quot;);                  //开启串口COM4
            dbh.OpenDatabase();                     //开启数据库
            CheckForIllegalCrossThreadCalls = false;        //允许后台线程直接操纵前台控件
            backgroundWorker1.RunWorkerAsync();         //开启后台线程
        }

        private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e)
        {
            bool successOrNot = sc.SetTargetAddress(0x01); //设置通讯目标地址为相应单片机
            toolStripStatusLabel1.Text = &quot;设置地址为02：失败&quot;;
            if (successOrNot) toolStripStatusLabel1.Text = &quot;设置地址为02：成功&quot;;//显示成功信息
            timer1.Start();                         //启动定时器
            while (true)
            {
                string commandTemp = dbh.commandValue.Trim();//调用数据库方法，读网页前端控制字
                if (commandTemp == &quot;k&quot;) kaiQiFlag = true;
                else if (commandTemp == &quot;g&quot;) guanBiFlag = true;
                else if (commandTemp == &quot;z&quot;) zanTingFlag = true;
                else if (commandTemp == &quot;t&quot;) tiaoSuFlag = true;
                else if (commandTemp == &quot;q&quot;) qiDongFlag = true;//根据网页前端控制字的不同，将相//应命令控制位置为true
                label4.Text = commandTemp;                  //显示网页前端控制字，方便调试
                dbh.RenewData(&quot;Curtain&quot;, &quot;Command&quot;, &quot;0&quot;);       //将网页端控制字清零
                if (kaiQiFlag) KaiQi();
                else if (guanBiFlag) GuanBi();
                else if (zanTingFlag) ZanTing();
                else if (tiaoSuFlag) TiaoSu();
                else if (qiDongFlag) QiDong();              //根据控制位执行相应操作
                else if (timerFlag)                         //定时器到设定时间
                {
                    timerFlag = false;                      //将定时器标志位清回false
                    Thread.Sleep(1000);                     //延时1秒，等待单片机准备好
  button1.Enabled = button2.Enabled = button4.Enabled = speedBtn.Enabled = false;                                   //正式开始执行电机状态询问前，                                              //先禁用所有按钮，防止产生混乱
                    sc.SendAck();                           //发送Ack
                    bool gotOrNot = sc.GetAck();                //检测是否收到Got
                    if (gotOrNot) toolStripStatusLabel1.Text += &quot; 握手成功&quot;;
                    else toolStripStatusLabel1.Text += &quot; 握手失败&quot;;
                    Thread.Sleep(1000);                     //延时，等待单片机做好接受准备
                    sc.SendAck();                           //发送Ack

                    byte[] dataByte = sc.SerialData;
                    ASCIIEncoding ae = new ASCIIEncoding();
                    string stts = ae.GetString(dataByte, 0, 1);
                    string spd = ae.GetString(dataByte, 1, 1);
                    if (stts == &quot;k&quot;)
                    {
                        statusLbl.Text = &quot;开启&quot;;
                        dbh.RenewData(&quot;Curtain&quot;, &quot;Curtain&quot;, &quot;开启&quot;);
                    }
                    else if (stts == &quot;g&quot;)
                    {
                        statusLbl.Text = &quot;关闭&quot;;
                        dbh.RenewData(&quot;Curtain&quot;, &quot;Curtain&quot;, &quot;关闭&quot;);
                    }
                    else if (stts == &quot;y&quot;)
                    {
                        statusLbl.Text = &quot;运行中&quot;;
                        dbh.RenewData(&quot;Curtain&quot;, &quot;Curtain&quot;, &quot;运行中&quot;);
                    }
                    else if (stts == &quot;t&quot;)
                    {
                        statusLbl.Text = &quot;暂停中&quot;;
                        dbh.RenewData(&quot;Curtain&quot;, &quot;Curtain&quot;, &quot;暂停中&quot;);
                    }
                    speedLbl.Text = spd;                    //接收并显示单片机传来的状态信息
                    Thread.Sleep(1000);                     //延时
                    button1.Enabled = button2.Enabled = button4.Enabled = speedBtn.Enabled = true;                                                  //状态询问执行完毕，恢复按钮功能
                }
            }
        }

        private void KaiQi()                                //开启功能
        {
            kaiQiFlag = false;                              //开启标志位清回false
            sc.SendAck();                                   //发送Ack
            bool gotOrNot = sc.GetAck();                    //检测是否收到Got
            if (gotOrNot) toolStripStatusLabel1.Text = &quot; 握手成功&quot;;
            else toolStripStatusLabel1.Text = &quot; 握手失败&quot;;
            Thread.Sleep(1000);                         //延时，等待单片机做好准备
            sc.SendMessage(&quot;OpnX&quot;);                         //发送Opn
            bool gotOrNot2 = sc.GetAck();                   //检测是否收到Got
            if (!gotOrNot2) toolStripStatusLabel1.Text = &quot;警告：电机无应答&quot;;
            else toolStripStatusLabel1.Text += &quot; 开启成功&quot;;
        }

        private void GuanBi()                               //关闭功能同上
        {
            guanBiFlag = false;
            backgroundWorker1.CancelAsync();
            sc.SendAck();
            bool gotOrNot = sc.GetAck();
            if (gotOrNot) toolStripStatusLabel1.Text = &quot; 握手成功&quot;;
            else toolStripStatusLabel1.Text = &quot; 握手失败&quot;;
            Thread.Sleep(1000);
            sc.SendMessage(&quot;ClsX&quot;);
            gotOrNot = sc.GetAck();
            if (!gotOrNot) toolStripStatusLabel1.Text = &quot;警告：电机无应答&quot;;
            else toolStripStatusLabel1.Text += &quot; 关闭成功&quot;;
        }

        private void ZanTing()                              //暂停功能同上
        {
            zanTingFlag = false;
            backgroundWorker1.CancelAsync();
            sc.SendMessage(&quot;PauX&quot;);
            bool gotOrNot = sc.GetAck();
            if (!gotOrNot) toolStripStatusLabel1.Text = &quot;警告：电机无应答&quot;;
            else toolStripStatusLabel1.Text = &quot; 暂停成功&quot;;
        }

        private void TiaoSu()                               //调速功能同上
        {
            tiaoSuFlag = false;
            backgroundWorker1.CancelAsync();
            sc.SendAck();
            bool gotOrNot = sc.GetAck();
            if (gotOrNot) toolStripStatusLabel1.Text = &quot; 握手成功&quot;;
            else toolStripStatusLabel1.Text = &quot; 握手失败&quot;;
            Thread.Sleep(1000);
            sc.SendMessage(&quot;Spe&quot; + numericUpDown1.Value.ToString() + &quot;X&quot;);
            gotOrNot = sc.GetAck();
            if (gotOrNot) toolStripStatusLabel1.Text += &quot; 设置速度成功&quot;;
            else toolStripStatusLabel1.Text += &quot; 握手失败&quot;;
        }

        private void QiDong()                               //启动功能同上
        {
            qiDongFlag = false;
            backgroundWorker1.CancelAsync();
            sc.SendMessage(&quot;SttX&quot;);
            bool gotOrNot = sc.GetAck();
            if (!gotOrNot) toolStripStatusLabel1.Text = &quot;警告：电机无应答&quot;;
            else toolStripStatusLabel1.Text = &quot; 启动成功&quot;;
        }

        private void button1_Click(object sender, EventArgs e) //单击按钮则开启标志位置true
        {
            kaiQiFlag = true;
        }

        private void button2_Click(object sender, EventArgs e)
        {
            guanBiFlag = true;
        }

        private void button4_Click(object sender, EventArgs e)
        {
            zanTingFlag = true;
        }

        private void button3_Click(object sender, EventArgs e)
        {
            qiDongFlag = true;
        }

        private void speedBtn_Click(object sender, EventArgs e)
        {
            tiaoSuFlag = true;
        }

        private void timer1_Tick(object sender, EventArgs e) //定时器到期则置定时器标志位为true
        {
            timerFlag = true;
        }
    }
}
</code></pre>
</body></html>